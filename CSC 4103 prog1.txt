fileio.h

/////////////////////////////////////////////////////////////////////
// Intentionally flawed system call library that (doesn't really)
// implement "safe" file I/O.  The intention is to disallow writing
// "\xFE\xED\xFA\xCE" and "\xFE\xED\xFA\xCF" at the beginning of a
// file.  Written by Golden G. Richard III (@nolaforensix).  Props to
// Brian Hay for the idea, based on a similar exercise he used in a
// training exercise.
/////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// filesystem error code
typedef enum  {
  NONE, 
  OPEN_FAILED,
  CLOSE_FAILED,
  READ_FAILED,
  WRITE_FAILED,
  ILLEGAL_MACHO
} FSError;

// file handle type           // <---- YOU WILL HAVE TO MODIFY THIS TYPE! Hint: File should become
typedef FILE* File;           // <---- a pointer to a structure type that contains the FILE * field 
                              // <---- and some other stuff
// seek anchors
typedef enum {
  BEGINNING_OF_FILE, 
  CURRENT_POSITION, 
  END_OF_FILE
} SeekAnchor;

// function prototypes for system calls provided by "fileio.c"

// opens file with pathname 'name'. Files are always opened for
// read/write access.  If the open fails for any reason, the global
// 'fserror' is set to OPEN_FAILED, otherwise to NONE.
File open_file(char *name);        // <---- YOU WILL HAVE TO MODIFY THIS FUNCTION!

// closes file with handle 'file'. If the close fails for any reason,
// the global 'fserror' is set to CLOSE_FAILED, otherwise to NONE.
void close_file(File file);

// reads 'num_bytes' into 'data' from 'file' at 'offset' bytes from a
// particular 'start'-ing position.  Returns the number of bytes
// read. If the read fails for any reason, the global 'fserror' is set
// to READ_FAILED, otherwise to NONE.
unsigned long read_file_from(File file,
			     void *data,
			     unsigned long num_bytes,
			     SeekAnchor start,
			     long offset);

// writes 'num_bytes' from 'data' into 'file' at 'offset' bytes from a
// particular 'start'-ing position. Returns the number of bytes
// written.  Disallows writing "\xFE\xED\xFA\xCE" or
// "\xFE\xED\xFA\xCF" at the beginning of a file.  If an attempt is
// made to modify a file such that one of the forbidden strings would
// appear in the first four bytes of the file, the write operation
// fails and ILLEGAL_MACHO is stored in the global 'fserror'.  If the
// write fails for any other reason, 'fserror' is set to WRITE_FAILED,
// otherwise to NONE.
unsigned long write_file_at(File file,
			    void *data,
			    unsigned long num_bytes, 
			    SeekAnchor start,
			    long offset);         // <---- YOU WILL HAVE TO MODIFY THIS FUNCTION!

// describes current filesystem error code 
void fs_print_error(void);

// GLOBALS //

// filesystem error code set (set by each function)
extern FSError fserror;



fileio.c 
/////////////////////////////////////////////////////////////////////
// Intentionally flawed system call library that (doesn't really)
// implement "safe" file I/O.  The intention is to disallow writing
// "\xFE\xED\xFA\xCE" and "\xFE\xED\xFA\xCF" at the beginning of a
// file.  Written by Golden G. Richard III (@nolaforensix).  Props to
// Brian Hay for the idea, based on a similar exercise he used in a
// training exercise.
/////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "fileio.h"

//
// GLOBALS
//

FSError fserror;

//
// private functions
//

static bool seek_file(File file, SeekAnchor start, long offset) {
  
  if (! file || (start != BEGINNING_OF_FILE && 
		 start != CURRENT_POSITION && start != END_OF_FILE)) {
    return false;
  }
  else {
    if (! fseek(file, offset, start == BEGINNING_OF_FILE ? SEEK_SET : 
		(start == END_OF_FILE ? SEEK_END : SEEK_CUR))) {
      return true;
    }
    else {
      return false;
    }
  }
}

//
// public functions
//

// opens file with pathname 'name'. Files are always opened for
// read/write access.  If the open fails for any reason, the global
// 'fserror' is set to OPEN_FAILED, otherwise to NONE.
File open_file(char *name) {
  
  File fp;


  // HINT:  Your new implementation probably needs a call to malloc()!
  
  fserror = NONE;
  
  // try to open existing file
  fp = fopen(name, "r+");
  if (! fp) {
    // fail, fall back to creation
    fp = fopen(name, "w+");
    if (! fp) {
      fserror = OPEN_FAILED;
      return NULL;
    }
  }
  
  return fp;
}

// closes file with handle 'file'. If the close fails for any reason,
// the global 'fserror' is set to CLOSE_FAILED, otherwise to NONE.
void close_file(File file) {

  if (file && ! fclose(file)) {
    fserror=NONE;
  }
  else {
    fserror = CLOSE_FAILED;
  }
}

// reads 'num_bytes' into 'data' from 'file' at 'offset' bytes from a
// particular 'start'-ing position.  Returns the number of bytes
// read. If the read fails for any reason, the global 'fserror' is set
// to READ_FAILED, otherwise to NONE.
unsigned long read_file_from(File file, void *data, unsigned long num_bytes, 
			     SeekAnchor start, long offset) {

  unsigned long bytes_read = 0L;

  fserror = NONE;

  if (! file || ! seek_file(file, start, offset)) {
    fserror = READ_FAILED;
  }
  else {
    bytes_read = fread(data, 1, num_bytes, file);
    if (ferror(file)) {
      fserror = READ_FAILED;
    }
  }

  return bytes_read;
}

// writes 'num_bytes' from 'data' into 'file' at 'offset' bytes from a
// particular 'start'-ing position. Returns the number of bytes
// written.  Disallows writing "\xFE\xED\xFA\xCE" or
// "\xFE\xED\xFA\xCF" at the beginning of a file.  If an attempt is
// made to modify a file such that one of the forbidden strings would
// appear in the first four bytes of the file, the write operation
// fails and ILLEGAL_MACHO is stored in the global 'fserror'.  If the
// write fails for any other reason, 'fserror' is set to WRITE_FAILED,
// otherwise to NONE.
unsigned long write_file_at(File file, void *data, unsigned long num_bytes, 
			    SeekAnchor start, long offset) {
  
  unsigned long bytes_written = 0L;
  unsigned char *d = (unsigned char *)data;

  fserror = NONE;
  if (! file || ! seek_file(file, start, offset)) {
    fserror = WRITE_FAILED;
  }
  else if (offset == 0L &&
	   num_bytes >= 4 &&
	   d[0] == 0xFE &&
	   d[1] == 0xED &&
	   d[2] == 0xFA &&
	   (d[3] == 0xCE || d[3] == 0xCF)) {
    // don't let 0xfeedface or 0xfeedfacf ever appear at the
    // beginning of the file!  IT CAN'T BE THIS EASY, CAN IT?
    fserror = ILLEGAL_MACHO;
  }
  else {
    bytes_written = fwrite(data, 1, num_bytes, file);
    if (bytes_written < num_bytes) {
      fserror = WRITE_FAILED;
    }
  }
  return bytes_written;
}

// describes current filesystem error code 
void fs_print_error(void) {

  printf("FS ERROR: ");
  switch (fserror) {
  case NONE:
    puts("NONE");
    break;
  case OPEN_FAILED:
    puts("OPEN_FAILED");
    break;
  case CLOSE_FAILED:
    puts("CLOSE_FAILED");
    break;
  case READ_FAILED:
    puts("READ_FAILED");
    break;
  case WRITE_FAILED:
    puts("WRITE_FAILED");
    break;
  case ILLEGAL_MACHO:
    puts("ILLEGAL_MACHO: SHAME ON YOU!");
    break;
  default:
    puts("** UNKNOWN ERROR **");
  }
}


Test case 0:
// Compile:
//
// gcc -o rw-test-0 rw-test-0.c fileio.c
// 
// This is a standalone test.
// 

#include <stdio.h>
#include <unistd.h>
#include "fileio.h"

#define DATA1 "\xFE\xED\xFA\xCE"
#define DATA2 "\xFE\xED\xFA\xCF"
#define DATA3 "HELLO THERE!"

int main(int argc, char *argv[]) {
  
  File f;

  unlink("macho.dat");
  
  printf("\nAbout to open file \"macho.dat\"...\n");
  f=open_file("macho.dat");
  fs_print_error();

  printf("\nAbout to write DATA1 (should fail  with ILLEGAL_MACHO)...\n");
  write_file_at(f, DATA1, strlen(DATA1), BEGINNING_OF_FILE, 0L);
  fs_print_error();

  printf("\nAbout to write DATA2 (should fail with ILLEGAL_MACHO)... \n");
  write_file_at(f, DATA2, strlen(DATA2), BEGINNING_OF_FILE, 0L);
  fs_print_error();

  printf("\nAbout to write DATA3...\n");
  write_file_at(f, DATA3, strlen(DATA3), BEGINNING_OF_FILE, 0L);
  fs_print_error();

  printf("\nAbout to close file \"macho.dat\"...\n");
  close_file(f);
  fs_print_error();
  return 0;
}
  

Test Case 1:

// Compile:
//
// gcc -o rw-test-1 rw-test-1.c fileio.c
// 
// Run this test BEFORE rw-test-2.
// 

#include <stdio.h>
#include <unistd.h>
#include "fileio.h"

int main(int argc, char *argv[]) {
  
  File f;
  
  unlink("badmacho.dat");

  printf("\nAbout to open file \"badmacho.dat\"...\n");
  f=open_file("badmacho.dat");
  fs_print_error();

  printf("\nAbout to write one byte (0xFE)...\n");
  write_file_at(f, "\xFE", 1, BEGINNING_OF_FILE, 0L);
  fs_print_error();

  printf("\nAbout to close file \"badmacho.dat\"...\n");
  close_file(f);
  fs_print_error();
  
  return 0;
}
  
Test Case 2:

// Compile:
//
// gcc -o rw-test-2 rw-test-2.c fileio.c
// 
// Run this test AFTER rw-test-1.  DO NOT delete "badmacho.dat" before
// running this test.
// 

#include <stdio.h>
#include <unistd.h>
#include "fileio.h"

int main(int argc, char *argv[]) {
  
  File f;

  printf("\nAbout to open file \"badmacho.dat\"...\n");
  f=open_file("badmacho.dat");
  fs_print_error();

  printf("\nAbout to write bytes 0xED, 0xFA, 0xCE (should fail with ILLEGAL_MACHO)...\n");
  write_file_at(f, "\xED\xFA\xCE", 3, END_OF_FILE, 0L);
  fs_print_error();

  printf("\nAbout to close file \"badmacho.dat\"...\n");
  close_file(f);
  fs_print_error();

  return 0;
}


Test Case 3:

// Compile:
//
// gcc -o rw-test-3 rw-test-3.c fileio.c
// 
// This is a standalone test.
// 

#include <stdio.h>
#include <unistd.h>
#include "fileio.h"

int main(int argc, char *argv[]) {

  File f;
  
  unlink("another.dat");

  printf("\nAbout to open file \"another.dat\"...\n");
  f=open_file("another.dat");
  fs_print_error();

  printf("\nAbout to write HELLOTHERE...\n");
  write_file_at(f, "HELLOTHERE", strlen("HELLOTHERE"), BEGINNING_OF_FILE, 0L);
  fs_print_error();

  printf("\nAbout to write one byte (0xCF)...\n");
  write_file_at(f, "\xCF", 1, END_OF_FILE, -7L);
  fs_print_error();

  printf("\nAbout to write one byte (0xCF)...\n");
  write_file_at(f, "\xFA", 1, END_OF_FILE, -8L);
  fs_print_error();

  printf("\nAbout to write one byte (0xED)...\n");
  write_file_at(f, "\xED", 1, END_OF_FILE, -9L);
  fs_print_error();

  printf("\nAbout to write one byte (0xFE) (should fail with ILLEGAL_MACHO)...\n");
  write_file_at(f, "\xFE", 1, END_OF_FILE, -10L);  
  fs_print_error();
  
  printf("\nAbout to close file \"another.dat\"...\n");
  f=open_file("another.dat");
  fs_print_error();
  
  return 0;
}

Test Case 4:

// Compile:
//
// gcc -o rw-test-4 rw-test-4.c fileio.c
// 
// This is a standalone test.
//

#include <stdio.h>
#include <unistd.h>
#include "fileio.h"

int main(int argc, char *argv[]) {
  
  File f1, f2;
  
  unlink("one.dat");
  unlink("two.dat");

  printf("\nAbout to open file \"one.dat\"...\n");
  f1=open_file("one.dat");
  fs_print_error();

  printf("\nAbout to write bytes 0xED, 0xFA, 0xCE to \"one.dat\"...\n");  
  write_file_at(f1, "\xED\xFA\xCE", 3, BEGINNING_OF_FILE, 1L);
  fs_print_error();

  printf("\nAbout to open file \"two.dat\"...\n");
  f2=open_file("two.dat");
  fs_print_error();

  printf("\nAbout to write AB to \"two.dat\"...\n");  
  write_file_at(f2, "AB", 2, BEGINNING_OF_FILE, 0L);
  fs_print_error();

  printf("\nAbout to write byte (0xFE) to \"one.dat\" (should fail with ILLEGAL_MACHO)...\n");  
  write_file_at(f1, "\xFE", 1, BEGINNING_OF_FILE, 0L);
  fs_print_error();

  printf("\nAbout to close file \"one.dat\"...\n");
  close_file(f1);
  fs_print_error();

  printf("\nAbout to close file \"two.dat\"...\n");
  close_file(f2);
  fs_print_error();
  return 0;
}
  



